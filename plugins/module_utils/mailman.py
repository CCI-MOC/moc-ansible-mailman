import json
import logging
import os
import subprocess
import tempfile

log = logging.getLogger(__name__)
default_path = '/usr/lib/mailman/bin'


class MailmanError(Exception):
    '''Base class for all exceptions generated by this module'''


class CalledProcessError(MailmanError):
    def __init__(self, command, returncode, stdout, stderr):
        self.command = command
        self.returncode = returncode
        self.stdout = stdout
        self.stderr = stderr


class InvalidCommandError(MailmanError):
    pass


class Mailman(object):
    def __init__(self, path=None, allowed_commands=None):
        self.path = path or default_path
        self.allowed_commands = allowed_commands or []

    # we have to use **kwargs here because of python2 (we can't
    # have keyword arguments following *args)
    def run(self, cmd, *args, **kwargs):
        '''Run a mailman command, returning the decoded output.

        Raises InvalidCommandError if the given command is not
        in self.allowed_commands, starts with a '/', or contains '..'.

        Raises CalledProcessError if a command returns a nonzero
        exit status.
        '''

        if cmd.startswith('/'):
            raise InvalidCommandError(cmd)

        if '..' in cmd:
            raise InvalidCommandError(cmd)

        if self.allowed_commands and cmd not in self.allowed_commands:
            raise InvalidCommandError(cmd)

        stdin = kwargs['stdin'].encode() if 'stdin' in kwargs else None
        raw = kwargs.get('raw')
        cmdvec = [os.path.join(self.path, cmd)]
        cmdvec.extend(args)

        log.debug('running command: %s', cmdvec)
        p = subprocess.Popen(
            cmdvec,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )

        out, err = p.communicate(input=stdin)
        ret = p.wait()

        if ret != 0:
            raise CalledProcessError(cmdvec, ret, out, err)

        return out if raw else out.decode()

    def list_lists(self,
                   advertised_only=False,
                   domain=None):
        '''Returns a list of mailing list names'''

        args = ['-b']

        if advertised_only:
            args.append('-a')

        if domain:
            args.extend(('-V', domain))

        return self.run('list_lists', *args).splitlines()

    def list_all_members(self, listname):
        '''Returns a list of all members of the mailing list'''
        return self.run('list_members', listname).splitlines()

    def list_regular_members(self, listname):
        '''Returns a list of all regular (non-digest) members of the mailing list'''
        return self.run('list_members', '-r', listname).splitlines()

    def list_digest_members(self, listname):
        '''Returns a list of all digest members of the mailing list'''
        return self.run('list_members', '-d', listname).splitlines()

    def list_exists(self, listname):
        '''Returns True if the named list exists'''
        return listname in self.list_lists()

    def is_subscribed(self, email, listname):
        '''Returns True if the given email address is subscribed to the list'''
        return email in self.list_all_members(listname)

    def create_list(self, name, owner, password,
                    urlhost=None,
                    emailhost=None,
                    notify_owner=False):
        '''Create a mailing list.

        This will send a notification to the list owner unless
        notify_owner is False.
        '''

        args = []
        if urlhost:
            args.extend(('--urlhost', urlhost))
        if emailhost:
            args.extend(('--emailhost', emailhost))
        if not notify_owner:
            args.append('-q')

        args.extend((name, owner, password))
        return self.run('newlist', *args)

    def remove_list(self, name, remove_archives=False):
        args = []
        if remove_archives:
            args.append('-a')

        args.append(name)
        return self.run('rmlist', *args)

    def add_members(self, listname, members,
                    digest=False,
                    notify_members=False,
                    notify_admins=False):
        '''Add members to a list'''

        return self.run(
            'add_members',
            '-w{}'.format('y' if notify_members else 'n'),
            '-a{}'.format('y' if notify_admins else 'n'),
            '-d' if digest else '-r', '-',
            listname,
            stdin='\n'.join(members))

    def add_regular_members(self, listname, members,
                            notify_members=False,
                            notify_admins=False):
        '''Add regular (non-digest) members to a list'''

        return self.add_members(listname, members, digest=False,
                                notify_members=notify_members,
                                notify_admins=notify_admins)

    def add_digest_members(self, listname, members,
                           notify_members=False,
                           notify_admins=False):
        '''Add digest members to a list'''

        return self.add_members(listname, members, digest=True,
                                notify_members=notify_members,
                                notify_admins=notify_admins)

    def remove_members(self, listname, members,
                       notify_members=False,
                       notify_admins=False):
        '''Remove members from a list'''

        args = ['-f', '-']

        if not notify_members:
            args.append('-n')

        if not notify_admins:
            args.append('-N')

        args.append(listname)

        return self.run(
            'remove_members',
            *args,
            stdin='\n'.join(members))

    def get_list_config(self, listname):
        '''Return the list configuration as a dictionary'''

        config = self.run('config_list', '-o', '-', listname, raw=True)
        ns = {}
        exec(config, ns)
        return {k: v
                for k, v in ns.items()
                if not k.startswith('_')}

    def set_list_config(self, listname, config):
        '''Configure listname using the contents of config.

        This is a bit of hack that takes advantage of the fact that
        the native JSON representation of types is compatible
        with Python. There's probably a better way to do it.
        '''

        with tempfile.NamedTemporaryFile() as fd:
            fd.write(b'true = True\n')
            fd.write(b'false = False\n')

            for k, v in config.items():
                fd.write('{} = {}\n'.format(k, json.dumps(v)).encode())

            fd.flush()
            return self.run('config_list', '-i', fd.name, listname)


if __name__ == '__main__':
    logging.basicConfig(level='DEBUG')
